# 最长重复子串



## 一、核心定义与问题边界

最长重复子串指**在给定字符串中，至少出现两次的最长连续字符序列**，需明确两个关键边界：

1. **重复判定**：默认允许子串 “重叠”（如字符串`"aaaaa"`中，最长重复子串为`"aaaa"`，分别从索引 0 和 1 开始，存在重叠）；部分场景会限定 “非重叠”，需结合具体需求调整。
2. **空串与单字符处理**：若字符串长度≤1，不存在重复子串，结果为空；若所有字符均不重复（如`"abcd"`），同样无重复子串。

**示例**：对字符串`"banana"`，最长重复子串为`"ana"`（分别出现于索引 0-2 和 2-4）；对`"abracadabra"`，最长重复子串为`"abra"`（出现于索引 0-3 和 7-10）。



## 二、常见求解算法及性能分析

### 1. 暴力法（Brute-force）：直观但低效

#### 核心思路

1. 枚举所有可能的子串（从最长到最短）：子串长度从`n-1`（`n`为字符串长度）递减至 1。
2. 对每个长度`L`，遍历所有起始位置`i`（生成子串`s[i..i+L-1]`），检查是否存在另一个起始位置`j≠i`，使得`s[j..j+L-1]`与该子串相等。
3. 找到第一个存在重复的子串，即为最长重复子串。
4. 若存在更长的子串，更新

#### 性能与局限

- 时间复杂度：**O(n³)**（枚举子串 O (n²)，子串比较 O (n)），仅适用于极短字符串（如`n≤100`），大规模字符串（如`n≥1000`）会严重超时。
- 优势：无需额外空间，逻辑直观易实现。



### 2. 排序后缀法（Sorted Suffixes）：降低比较复杂度

#### 核心思路

利用 “重复子串必然是某两个后缀的公共前缀” 这一特性，通过排序后缀简化比较：

1. 生成字符串的所有后缀（如`"banana"`的后缀为`"banana"`、`"anana"`、`"nana"`、`"ana"`、`"na"`、`"a"`）。
2. 对所有后缀按字典序排序（排序后相邻后缀的公共前缀更可能较长）。
3. 遍历排序后的相邻后缀，计算每对相邻后缀的**最长公共前缀（LCP）**，最长 LCP 即为最长重复子串。

#### 性能与局限

- 时间复杂度：**O(n²logn)**（生成后缀 O (n²)，排序 O (n²logn)，计算 LCP O (n²)），比暴力法高效，但仍不适用于`n≥10000`的大规模字符串。
- 优势：避免枚举所有子串，通过排序将 “找重复子串” 转化为 “找相邻后缀的公共前缀”，逻辑清晰。



## 三、应用场景

- **文本处理**：如文档去重（定位重复段落）、 plagiarism 检测（识别抄袭的连续文本）。
- **生物信息学**：分析 DNA 序列中的重复片段（如基因中的重复序列）。
- **数据压缩**：识别高频重复子串，用 “标记 + 长度” 替代重复内容，减少存储量。



## 四、常见问题与解决方案

1. **重复子串不唯一**：若存在多个长度相同的最长重复子串（如`"ababab"`中，`"aba"`和`"bab"`均为最长重复子串），需根据需求返回 “所有结果” 或 “第一个匹配结果”。
2. **非重叠约束**：若要求重复子串不重叠，在查重时需额外判断两个子串的位置是否无交集（如子串 1 的结束索引 < 子串 2 的起始索引）。
3. **大小写敏感**：默认区分大小写（如`"Ana"`与`"ana"`视为不同），若需忽略大小写，可先将字符串统一转为大写或小写再处理。