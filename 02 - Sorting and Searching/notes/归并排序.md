# 归并排序



## 一、核心原理与算法流程

归并排序是基于**分治法（Divide-and-Conquer）** 的经典排序算法，由约翰・冯・诺依曼（John von Neumann）发明（最初用于测试其设计的计算机性能），核心逻辑是 “先拆分、再排序、最后合并”，具体流程如下：



### 1. 分治法三步骤

1. **分解（Divide）**：将待排序数组（或子数组）从中间拆分为两个等长（或近似等长）的子数组，直到每个子数组仅含 1 个元素（单个元素默认有序）。

> 例：数组`[wendy, alice, dave, walter, carlos, carol, erin, oscar]`先拆分为`[wendy, alice, dave, walter]`和`[carlos, carol, erin, oscar]`，继续拆分至每个子数组仅 1 个元素。

2. **治理（Conquer）**：递归地对两个子数组执行归并排序，使两个子数组分别变为有序数组。

> 例：子数组`[wendy, alice]`递归拆分后，排序为`[alice, wendy]`；子数组`[dave, walter]`排序为`[dave, walter]`。

3. **合并（Merge）**：使用一个辅助数组，将两个有序子数组合并为一个完整的有序数组 —— 通过双指针分别遍历两个子数组，每次将 “更小的元素” 放入辅助数组，最终将辅助数组的内容复制回原数组，完成排序。

> 例：合并`[alice, wendy]`和`[dave, walter]`时，依次比较`alice<dave`（放 alice）、`wendy>dave`（放 dave）、`wendy>walter`（放 walter）、`wendy`（放 wendy），得到有序数组`[alice, dave, walter, wendy]`。



## 二、关键实现细节

### 1. 辅助数组优化（避免重复分配）

归并排序的合并步骤需依赖辅助数组存储临时结果，课件中采用 “**仅分配一次辅助数组**” 的优化：

- 在顶层`sort`方法中创建辅助数组`aux`（大小与原数组一致），而非在每次递归的`merge`方法中创建，避免递归过程中多次分配内存的开销，提升效率。



### 2. 合并操作的边界处理

合并子数组`a[lo..mid)`和`a[mid..hi)`时，需处理 “某一子数组已遍历完毕” 的边界情况：

- 若左子数组（`a[lo..mid)`）已遍历完（`i == mid`），直接将右子数组剩余元素放入辅助数组；
- 若右子数组（`a[mid..hi)`）已遍历完（`j == hi`），直接将左子数组剩余元素放入辅助数组；
- 若均未遍历完，比较`a[i]`与`a[j]`，将更小的元素放入辅助数组并移动对应指针。



### 3. 递归终止条件

当子数组长度为 1（即`hi - lo <= 1`，`N=1`）时，无需继续拆分，直接返回（单个元素天然有序）。



## 三、性能分析

### 1. 时间复杂度

- **理论复杂度**：`O(nlogn)`，推导逻辑如下：
  1. 分解过程：将数组拆分为`logn`层（如`n=16`时拆分为 4 层，`log₂16=4`）；
  2. 合并过程：每一层的合并操作需遍历`n`个元素（所有子数组的总元素数为`n`），耗时`O(n)`；
  3. 总时间：`logn`层 × 每层`O(n)` = `O(nlog n)`。
- **实证验证**（排序 10 字符随机字符串）：

| 待排序数组长度`N` | 运行时间`T(N)`（秒） | 时间比值`T(N)/T(N/2)`（`N`翻倍时的增长倍数） |
| ----------------- | -------------------- | -------------------------------------------- |
| 1,000,000         | 1                    | -                                            |
| 2,000,000         | 2                    | 2                                            |
| 4,000,000         | 5                    | 2.5                                          |
| 8,000,000         | 10                   | 2                                            |
| 16,000,000        | 20                   | 2.5                                          |
| 1,024,000,000     | 1280（约 21 分钟）   | 2                                            |

- 结论：`N`翻倍时，时间增长约 2 倍（因`log(2N)=logN+1`，`nlogn`增长接近线性），验证了`O(nlogn)`的时间复杂度。



### 2. 空间复杂度

- **理论复杂度**：`O(n)`，因需一个与原数组大小相同的辅助数组`aux`（仅额外占用`n`个元素的空间，递归调用栈的空间为`O(logn)`，可忽略）。
- **与插入排序对比**：插入排序是 “原地排序”（`O(1)`空间），而归并排序需额外空间，但时间效率远高于插入排序。



## 四、算法特性

### 1. 核心优势

- **可扩展性强**：符合`O(n log n)`复杂度，是课件中明确的 “可扩展算法”—— 硬件升级（如 2 倍 CPU 速度 + 2 倍内存）时，可在相同时间内处理 2 倍规模的数据（如原处理`800万`数据需 10 秒，升级后可处理`1600万`数据仍需 10 秒）。
- **稳定性高**：合并过程中，若两个子数组的元素相等，优先选择左子数组的元素，可保持相等元素的相对顺序（适用于 “多字段排序” 场景，如先按年龄排序、再按姓名排序）。
- **对大规模数据友好**：相比插入排序（`O(n²)`，`N=128万`需 4 小时），归并排序处理`1024万`数据仅需约 21 分钟，适合大规模数据排序。

### 2. 局限性

- **空间开销大**：需额外存储辅助数组，对内存受限的场景（如嵌入式设备）不够友好。
- **小规模数据效率略低**：递归调用有一定开销，对`N≤100`的小规模数据，性能略逊于插入排序（插入排序无递归开销，且对接近有序数据更高效）。



## 五、应用场景

1. **大规模数据排序**：如数据库索引排序、日志文件排序（数据量百万级以上）；
2. **稳定排序需求**：如电商订单排序（先按订单金额排序，金额相同时按下单时间排序）；
3. **外部排序（External Sorting）**：处理无法完全装入内存的大文件时，归并排序的 “分治” 逻辑可用于 “分块排序 + 合并”（如硬盘文件排序）。