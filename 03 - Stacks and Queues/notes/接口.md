# 接口

## 一、基础概念：数据类型与数据结构

### 1. 数据类型的定义与分类

数据类型是对 “值的集合” 及 “该集合上可执行的操作” 的抽象，课件中将其分为两类：

- **内置数据类型**：Java 原生支持，如`int`（整数）、`double`（浮点数）、`String`（字符串），无需手动定义即可直接使用。

- **自定义数据类型**：需通过类实现，用于描述特定领域的实体及操作，例如：

  > `Complex`类：存储复数（实部`real`、虚部`imag`），提供加法（`plus`）、乘法（`times`）、求模（`abs`）等操作；
  >
  > `Charge`类：描述电荷相关属性，提供旋转（`turnLeft`）、移动（`goForward`）等操作；
  >
  > 核心特征：需明确 “值的构成” 与 “可执行的操作”，是抽象数据类型（ADT）的具体体现。

### 2. 数据结构的定义与分类

数据结构用于 “表示数据” 及 “数据间的关系”，同样分为两类：

- **内置数据结构**：Java 原生支持，如一维数组（1D arrays）、二维数组（2D arrays），适合存储线性排列的数据。
- **自定义数据结构**：需手动设计实现，如链表（linked list）、循环列表（circular list）、树（tree）等，用于满足复杂的数据组织需求（如动态增减数据、层级关系存储）。

### 3. 核心设计挑战

针对任意数据类型，核心问题是 “选择何种数据结构实现”，需权衡两个关键资源：

- **内存开销**：数据结构占用的存储空间大小；
- **时间效率**：数据类型的各类操作（如增、删、查）所需的执行时间。



## 二、核心抽象：栈与队列的 API 定义

栈和队列是两种基础的 “集合型 ADT”，核心差异仅在于 “元素移除的顺序规则”，二者均为 “无固定大小限制” 的集合（理论上可存储任意多元素，随需求动态变化）。

### 1. 栈：后进先出

栈的操作围绕 “栈顶” 展开，仅允许从栈顶添加或移除元素，API 包含 4 个核心方法：

| 方法签名               | 功能描述                                  |
| ---------------------- | ----------------------------------------- |
| `Stack<Item>()`        | 构造一个空栈，元素类型为`Item`（泛型）    |
| `void push(Item item)` | 向栈顶添加一个元素`item`                  |
| `Item pop()`           | 移除并返回栈顶元素（即 “最近添加的元素”） |
| `boolean isEmpty()`    | 判断栈是否为空（空则返回`true`）          |
| `int size()`           | 返回栈中元素的个数                        |

- **核心特征**：元素的 “添加” 与 “移除” 均在同一端（栈顶），符合 “后进先出” 规则，例如 “浏览器后退按钮”“函数调用栈” 均基于此逻辑。

### 2. 队列：先进先出

队列的操作围绕 “队头” 和 “队尾” 展开，元素从队尾添加、从队头移除，API 同样包含 4 个核心方法：

| 方法签名                  | 功能描述                                  |
| ------------------------- | ----------------------------------------- |
| `Queue<Item>()`           | 构造一个空队列，元素类型为`Item`（泛型）  |
| `void enqueue(Item item)` | 向队尾添加一个元素`item`                  |
| `Item dequeue()`          | 移除并返回队头元素（即 “最早添加的元素”） |
| `boolean isEmpty()`       | 判断队列是否为空（空则返回`true`）        |
| `int size()`              | 返回队列中元素的个数                      |

- **核心特征**：元素的 “添加” 在队尾、“移除” 在队头，符合 “先进先出” 规则，例如 “排队购票”“打印机任务调度” 均基于此逻辑。

### 3. 共性与应用场景

- **共性**：二者均为 “动态集合”，无内置大小限制，且均需支持 “添加元素”“移除元素”“判断空”“统计大小” 四大基础操作，是无数实际应用的底层抽象。
- **自然场景**：二者在现实与程序中均广泛存在（如栈对应 “资源的后进先出分配”，队列对应 “资源的先进先出分配”），无需额外设计即可适配多数线性数据处理需求。



## 三、技术优化：参数化数据类型（泛型）

### 1. 设计目标

解决 “集合 ADT 适配多类型元素” 的问题，让客户端代码更简单、安全、清晰 —— 无需为每种元素类型（如`int`、`String`、自定义类）单独实现栈或队列，而是通过 “占位符类型” 统一适配。

### 2. Java 实现方式

- **定义阶段**：使用占位符类型名（如`Item`）描述元素类型，例如`public class Stack<Item>`表示 “一个元素类型为`Item`的栈类”，`public class Queue<Item>`表示 “一个元素类型为`Item`的队列类”。
- **使用阶段**：客户端在创建实例时，将占位符替换为具体类型（如`Stack<String>`表示 “存储字符串的栈”，`Queue<Integer>`表示 “存储整数的队列”），避免类型转换错误，提升代码安全性。



## 四、性能基准：性能规格

### 1. 核心要求

课件明确，一个 “合格的栈 / 队列实现” 必须满足以下性能指标，否则不能视为真正实现了栈 / 队列的抽象：

1. **时间效率**：所有 API 方法（`push`/`pop`/`enqueue`/`dequeue`/`isEmpty`/`size`）的执行时间均为**常数时间（O (1)）** —— 操作耗时不随元素数量增加而变化；
2. **内存效率**：当集合非空时，内存占用与集合大小呈**线性关系（O (n)）** —— 仅存储必要的元素及结构信息，无冗余开销；
3. **大小灵活性**：代码内部不限制集合的最大容量，支持随元素添加动态扩展（无需客户端提前指定容量）。

### 2. 关键意义

性能规格是 “客户端代码可扩展” 的前提 —— 只有满足常数时间操作和线性内存，栈 / 队列才能适配大规模数据场景（如百万级元素存储与操作），否则会因性能瓶颈无法支撑实际应用。

