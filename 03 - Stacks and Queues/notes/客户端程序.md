# 客户端程序

## 一、Clients 部分核心定位

本节聚焦栈与队列的**实际应用场景**及**客户端代码实现**，通过具体案例展示如何基于栈 / 队列的 API 解决实际问题，同时补充客户端使用泛型 ADT（抽象数据类型）的关键技术，核心是 “将栈 / 队列的抽象逻辑落地为可执行的程序功能”。



## 二、队列的客户端应用与示例

队列基于 “先进先出” 特性，客户端场景集中在 “需按顺序处理数据” 的需求，文档明确了其应用领域及具体实现案例。

### 1. 典型应用场景

队列的客户端应用均围绕 “顺序优先级” 展开，具体包括：

- **先进先出资源分配**：如排队获取资源（购票、办理业务），先请求的先获得服务；
- **异步数据传输**：如标准输入（StdIn）、标准输出（StdOut）的数据流处理，数据按接收顺序依次传输；
- **共享资源请求分配**：如多进程对打印机、数据库连接等共享资源的请求，按请求顺序分配资源避免冲突；
- **现实世界模拟**：如交通流量（车辆排队进入隧道）、生产流水线（产品按顺序加工）等场景的程序模拟。



### 2. 核心客户端示例：标准输入字符串读入数组

#### （1）问题痛点

客户端需将标准输入（StdIn）中的所有字符串读入数组，但存在 “三难” 矛盾：无法在创建数组前存储字符串、无法在未知字符串数量时创建数组、无法在不读取所有字符串时知道数量。

#### （2）解决方案：基于 Queue<String>实现

利用队列 “动态存储、可获取大小” 的特性，分四步解决问题：

1. 创建 Queue<String>实例，循环读取 StdIn 的字符串并通过`enqueue`存入队列；
2. 读取完毕后，通过`size()`获取字符串总数 N；
3. 创建大小为 N 的 String 数组；
4. 通过`dequeue`将队列中的字符串依次复制到数组中



## 三、栈的客户端应用与示例

栈基于 “后进先出” 特性，客户端场景集中在 “需回溯、逆序处理或临时存储最近数据” 的需求，文档提供了从日常功能到工业级应用的多个案例。

### 1. 典型应用场景

- **后进先出资源分配**：如叠放的盘子、堆存的货物，最后放入的先取出；
- **编程语言中的函数调用**：函数调用栈存储当前执行上下文，子函数执行完毕后回溯到父函数，符合 LIFO 逻辑；
- **解释器与编译器基础机制**：如表达式求值、语法分析，栈用于临时存储操作数或语法单元；
- **计算中的基础抽象**：是构建复杂算法（如深度优先搜索）和系统（如虚拟机）的底层组件。



### 2. 核心客户端示例 1：浏览器 “后退” 按钮

#### （1）场景逻辑

用户访问页面的过程为 “访问页面→点击链接跳转（多次）→点击后退（多次）”，需记录最近访问的页面，回溯时优先返回最后访问的页面，完全匹配栈的 LIFO 特性：

1. 每次访问新页面时，将页面 URL 通过`push`存入栈；
2. 点击 “后退” 按钮时，通过`pop`取出最近存入的 URL 并加载

#### （2）典型流程

- 访问顺序：`http://introcs.cs.princeton.edu/java/home/`→`http://introcs.cs.princeton.edu/java/40algorithms/`→`http://introcs.cs.princeton.edu/java/43stack/`（栈内依次 push 这三个 URL）；
- 后退顺序：第一次后退加载`http://introcs.cs.princeton.edu/java/40algorithms/`，第二次后退加载`http://introcs.cs.princeton.edu/java/home/`



### 3. 核心客户端示例 2：后缀表达式求值

#### （1）问题背景

中缀表达式（如`(1+((2+3)*(4*5)))`）需括号确定优先级，而后缀表达式（如`1 2 3 + 4 5 * * +`，又称逆波兰表示法）无需括号，仅通过栈即可高效求值。

#### （2）求值算法（基于栈）

1. 循环读取输入流中的 token（操作数或运算符）；
2. 若为**操作数**：通过`push`存入栈；
3. 若为**运算符**：通过`pop`取出栈顶 1 个（平方根`sqrt`）或 2 个（加减乘除）操作数，执行运算后将结果`push`回栈；
4. 输入结束后，栈中剩余的唯一元素即为表达式结果。



### 4. 工业级栈应用：PostScript 与 JVM

- **PostScript**：1980 年代推出的页面描述语言，本质是 “带栈的虚拟绘图机”，代码采用后缀形式（如`100 100 moveto`，先 push 坐标再调用`moveto`），栈用于存储绘图参数，推动了出版行业变革；
- **Java 虚拟机（JVM）**：作为栈式虚拟机，核心执行引擎依赖操作数栈，所有指令（如加载常量、执行运算）均通过栈完成，是 Java 跨平台能力的基础。



## 四、客户端使用的关键技术：自动装箱

### 1. 问题背景

客户端使用泛型栈 / 队列（如`Stack<Item>`、`Queue<Item>`）时，`Item`需为引用类型，而 Java 的基本数据类型（如`int`、`double`）无法直接作为泛型参数，需借助 “包装类”（如`Integer`、`Double`）。



### 2. 自动装箱与拆箱

- **自动装箱（Autoboxing）**：将基本类型自动转为对应包装类，如`stack.push(17)`（`int`→`Integer`）；
- **自动拆箱（Auto-unboxing）**：将包装类自动转为对应基本类型，如`int a = stack.pop()`（`Integer`→`int`）；
- **客户端价值**：无需手动强制类型转换，简化代码（如`Stack<Integer> stack = new Stack<Integer>()`可直接操作`int`类型）至。



### 3. 基本类型与包装类对应关系

| 基本类型（primitive type） | 包装类（wrapper type） |
| -------------------------- | ---------------------- |
| `int`                      | `Integer`              |
| `char`                     | `Character`            |
| `double`                   | `Double`               |
| `boolean`                  | `Boolean`              |